From 546ee21cdbdc276dbaeb6d6e7264b8695b8df0c8 Mon Sep 17 00:00:00 2001
From: sathonay <alexis.chamonix@gmail.com>
Date: Mon, 26 Aug 2019 17:11:40 +0200
Subject: [PATCH] Fix kncokback


diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index d4296131..7da4467c 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -14,11 +14,9 @@ import org.bukkit.craftbukkit.entity.CraftItem;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.Player;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
-import org.bukkit.event.player.PlayerBedEnterEvent;
-import org.bukkit.event.player.PlayerBedLeaveEvent;
-import org.bukkit.event.player.PlayerDropItemEvent;
-import org.bukkit.event.player.PlayerItemConsumeEvent;
+import org.bukkit.event.player.*;
 // CraftBukkit end
+import org.bukkit.util.Vector;
 import org.spigotmc.ProtocolData; // Spigot - protocol patch
 
 public abstract class EntityHuman extends EntityLiving implements ICommandListener {
@@ -948,16 +946,50 @@ public abstract class EntityHuman extends EntityLiving implements ICommandListen
                         // CraftBukkit end
                     }
 
+                    // Rinny start
+                    // Save the victim's velocity before they are potentially knocked back
+                    double victimMotX = entity.motX;
+                    double victimMotY = entity.motY;
+                    double victimMotZ = entity.motZ;
+                    // Rinny end
+
                     boolean flag2 = entity.damageEntity(DamageSource.playerAttack(this), f);
 
                     if (flag2) {
                         if (i > 0) {
-                            entity.g((double) (-MathHelper.sin(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F), 0.1D, (double) (MathHelper.cos(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F));
+                            entity.g((double) (-MathHelper.sin((float) (this.yaw * Math.PI / 180.0F)) * (float) i * 0.5F), 0.1D, (double) (MathHelper.cos((float) (this.yaw * Math.PI / 180.0F)) * (float) i * 0.5F));
                             this.motX *= 0.6D;
                             this.motZ *= 0.6D;
                             this.setSprinting(false);
                         }
 
+                        // Rinny start
+                        // If the attack caused knockback, send the new velocity to the victim's client immediately,
+                        // and undo the change. Otherwise, if movement packets from the victim are processed before
+                        // the end of the tick, then friction may reduce the velocity considerably before it's sent
+                        // to the client, particularly if the victim was standing on the ground when those packets
+                        // were generated. And because this glitch is also likely to make server-side velocity very
+                        // inconsistent, we simply reverse the knockback after sending it so that KB, like most other
+                        // things, doesn't affect server velocity at all.
+                        if (entity instanceof EntityPlayer && entity.velocityChanged) {
+                            Player player = (Player) entity.getBukkitEntity();
+                            Vector vector = new Vector(victimMotX, victimMotY, victimMotZ);
+
+                            PlayerVelocityEvent event = new PlayerVelocityEvent(player, vector.clone());
+                            this.world.getServer().getPluginManager().callEvent(event);
+                            if (!event.isCancelled()) {
+                                if(!vector.equals(event.getVelocity())) player.setVelocity(event.getVelocity());
+                                if (entity.motY > 0) entity.fallDistance = 0.0f;
+                                ((EntityPlayer) entity).playerConnection.sendPacket(new PacketPlayOutEntityVelocity(entity));
+                                entity.velocityChanged = false;
+                                entity.motX = victimMotX;
+                                entity.motY = victimMotY;
+                                entity.motZ = victimMotZ;
+                            }
+                        }
+                        // Rinny end
+
+
                         if (flag) {
                             this.b(entity);
                         }
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index f78a2a02..725df18a 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -828,18 +828,18 @@ public abstract class EntityLiving extends Entity {
     public void a(Entity entity, float f, double d0, double d1) {
         if (this.random.nextDouble() >= this.getAttributeInstance(GenericAttributes.c).getValue()) {
             this.al = true;
-            float f1 = MathHelper.sqrt(d0 * d0 + d1 * d1);
-            float f2 = 0.4F;
-
-            this.motX /= 2.0D;
-            this.motY /= 2.0D;
-            this.motZ /= 2.0D;
-            this.motX -= d0 / (double) f1 * (double) f2;
-            this.motY += (double) f2;
-            this.motZ -= d1 / (double) f1 * (double) f2;
-            if (this.motY > 0.4000000059604645D) {
-                this.motY = 0.4000000059604645D;
-            }
+            // Rinny start - configurable knockback
+            double magnitude = MathHelper.sqrt(d0 * d0 + d1 * d1);
+            double d2 = 0.4;
+
+            this.motX /= 2.0;
+            this.motY /= 2.0;
+            this.motZ /= 2.0;
+
+            this.motX -= d0 / magnitude * d2;
+            this.motY = MathHelper.limit(this.motY + d2, 0.05D, 4.0);
+            this.motZ -= d1 / magnitude * d2;
+            // Rinny end
         }
     }
 
diff --git a/src/main/java/net/minecraft/server/MathHelper.java b/src/main/java/net/minecraft/server/MathHelper.java
new file mode 100644
index 00000000..0f554610
--- /dev/null
+++ b/src/main/java/net/minecraft/server/MathHelper.java
@@ -0,0 +1,221 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class MathHelper {
+    private static float[] a = new float[65536];
+    private static final int[] b;
+
+    public static final float sin(float var0) {
+        return a[(int)(var0 * 10430.378F) & '\uffff'];
+    }
+
+    public static final float cos(float var0) {
+        return a[(int)(var0 * 10430.378F + 16384.0F) & '\uffff'];
+    }
+
+    public static final float c(float var0) {
+        return (float)Math.sqrt((double)var0);
+    }
+
+    public static final float sqrt(double var0) {
+        return (float)Math.sqrt(var0);
+    }
+
+    public static int d(float var0) {
+        int var1 = (int)var0;
+        return var0 < (float)var1 ? var1 - 1 : var1;
+    }
+
+    public static int floor(double var0) {
+        int var2 = (int)var0;
+        return var0 < (double)var2 ? var2 - 1 : var2;
+    }
+
+    public static long d(double var0) {
+        long var2 = (long)var0;
+        return var0 < (double)var2 ? var2 - 1L : var2;
+    }
+
+    public static float abs(float var0) {
+        return var0 >= 0.0F ? var0 : -var0;
+    }
+
+    public static int a(int var0) {
+        return var0 >= 0 ? var0 : -var0;
+    }
+
+    public static int f(float var0) {
+        int var1 = (int)var0;
+        return var0 > (float)var1 ? var1 + 1 : var1;
+    }
+
+    public static int f(double var0) {
+        int var2 = (int)var0;
+        return var0 > (double)var2 ? var2 + 1 : var2;
+    }
+
+    public static int a(int var0, int var1, int var2) {
+        if (var0 < var1) {
+            return var1;
+        } else {
+            return var0 > var2 ? var2 : var0;
+        }
+    }
+
+    public static float a(float var0, float var1, float var2) {
+        if (var0 < var1) {
+            return var1;
+        } else {
+            return var0 > var2 ? var2 : var0;
+        }
+    }
+
+    public static double a(double var0, double var2, double var4) {
+        if (var0 < var2) {
+            return var2;
+        } else {
+            return var0 > var4 ? var4 : var0;
+        }
+    }
+
+    public static double b(double var0, double var2, double var4) {
+        if (var4 < 0.0D) {
+            return var0;
+        } else {
+            return var4 > 1.0D ? var2 : var0 + (var2 - var0) * var4;
+        }
+    }
+
+    public static double a(double var0, double var2) {
+        if (var0 < 0.0D) {
+            var0 = -var0;
+        }
+
+        if (var2 < 0.0D) {
+            var2 = -var2;
+        }
+
+        return var0 > var2 ? var0 : var2;
+    }
+
+    public static int nextInt(Random var0, int var1, int var2) {
+        return var1 >= var2 ? var1 : var0.nextInt(var2 - var1 + 1) + var1;
+    }
+
+    public static float a(Random var0, float var1, float var2) {
+        return var1 >= var2 ? var1 : var0.nextFloat() * (var2 - var1) + var1;
+    }
+
+    public static double a(Random var0, double var1, double var3) {
+        return var1 >= var3 ? var1 : var0.nextDouble() * (var3 - var1) + var1;
+    }
+
+    public static double a(long[] var0) {
+        long var1 = 0L;
+        long[] var3 = var0;
+        int var4 = var0.length;
+
+        for(int var5 = 0; var5 < var4; ++var5) {
+            long var6 = var3[var5];
+            var1 += var6;
+        }
+
+        return (double)var1 / (double)var0.length;
+    }
+
+    public static float g(float var0) {
+        var0 %= 360.0F;
+        if (var0 >= 180.0F) {
+            var0 -= 360.0F;
+        }
+
+        if (var0 < -180.0F) {
+            var0 += 360.0F;
+        }
+
+        return var0;
+    }
+
+    public static double g(double var0) {
+        var0 %= 360.0D;
+        if (var0 >= 180.0D) {
+            var0 -= 360.0D;
+        }
+
+        if (var0 < -180.0D) {
+            var0 += 360.0D;
+        }
+
+        return var0;
+    }
+
+    public static int a(String var0, int var1) {
+        int var2 = var1;
+
+        try {
+            var2 = Integer.parseInt(var0);
+        } catch (Throwable var4) {
+        }
+
+        return var2;
+    }
+
+    public static int a(String var0, int var1, int var2) {
+        int var3 = var1;
+
+        try {
+            var3 = Integer.parseInt(var0);
+        } catch (Throwable var5) {
+        }
+
+        if (var3 < var2) {
+            var3 = var2;
+        }
+
+        return var3;
+    }
+
+    public static double a(String var0, double var1) {
+        double var3 = var1;
+
+        try {
+            var3 = Double.parseDouble(var0);
+        } catch (Throwable var6) {
+        }
+
+        return var3;
+    }
+
+    public static double a(String var0, double var1, double var3) {
+        double var5 = var1;
+
+        try {
+            var5 = Double.parseDouble(var0);
+        } catch (Throwable var8) {
+        }
+
+        if (var5 < var3) {
+            var5 = var3;
+        }
+
+        return var5;
+    }
+
+    public static double limit(double value, double min, double max) {
+        return Math.min(Math.max(value, min), max);
+    }
+
+    static {
+        for(int var0 = 0; var0 < 65536; ++var0) {
+            a[var0] = (float)Math.sin((double)var0 * 3.141592653589793D * 2.0D / 65536.0D);
+        }
+
+        b = new int[]{0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
+    }
+}
-- 
2.20.1.windows.1

